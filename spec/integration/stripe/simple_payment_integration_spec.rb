# frozen_string_literal: true

require "rails_helper"

# This file does not run on CI because it's suffixed `_real_spec.rb`
#
# The goal is to use Rspec to run real HTTP request against Stripe API to ensure
# things still work when upgrading the API version.
# This also creates logs on Stripe so you can copy past them to update the fixtures.

describe "Stripe Payment for Real", :scenarios, type: :request do
  let(:organization) { create(:organization, :premium, name: "Stripe IRL") }
  let(:addon) { create(:add_on, amount_cents: 310, amount_currency: currency, organization:, name: "Setup fee") }
  let(:external_id) { "#{Time.current.iso8601}--#{SecureRandom.hex(3)}" }
  let(:currency) { "EUR" }
  let(:api_key) { ENV["STRIPE_API_KEY"] }

  let(:provider) { organization.stripe_payment_providers.sole }

  include_context "with webhook tracking"

  around { |test| lago_premium!(&test) }

  before do
    raise "You need to set the SPEC_STRIPE_SECRET_KEY environment variable" unless api_key

    Stripe.api_version = ENV["STRIPE_API_VERSION"]
    Stripe.api_key = api_key
    WebMock.disable_net_connect!(allow: "api.stripe.com")

    # Setting up the stripe payment providers, which register the webhook endpoint
    ::PaymentProviders::StripeService.new.create_or_update(
      organization_id: organization.id,
      code: "stripe_spec",
      name: "Stripe Spec",
      secret_key: api_key,
      success_redirect_url: "https://app.lago.dev"
    )

    perform_all_enqueued_jobs
  end

  after do
    ids = []
    organization.stripe_payment_providers.each do |payment_provider|
      ids << payment_provider.webhook_id
      ::Stripe::WebhookEndpoint.delete(payment_provider.webhook_id, {})
    end

    ids.each do |id|
      ::Stripe::WebhookEndpoint.retrieve(id)
      raise StandardError, "#{id} was not deleted"
    rescue Stripe::InvalidRequestError
      nil
    end
  end

  it "can refresh the webhook endpoint" do
    expect(provider.webhook_id).to start_with "we_"
    expect(provider.webhook_secret).to start_with "whsec_"
    PaymentProviders::Stripe::RefreshWebhookService.call(provider.reload)
  end

  it "makes call to the actual API" do
    create_or_update_customer({
      external_id: "cust_#{external_id}",
      name: "Integration Test #{Time.current.iso8601}",
      currency:,
      country: "FR",
      billing_configuration: {
        payment_provider: "stripe",
        payment_provider_code: provider.code,
        sync: "true",
        sync_with_provider: "true",
        provider_payment_methods: [
          "card"
        ]
      }
    })

    expect(webhooks_sent.map { it["webhook_type"] }).to match_array(%w[
      customer.payment_provider_created customer.created customer.checkout_url_generated
    ])
    webhooks_sent.clear

    customer = Customer.find(json[:customer][:lago_id])
    stripe_customer = customer.payment_provider_customers.sole
    expect(stripe_customer.provider_customer_id).to start_with "cus_" # generated by stripe API

    # WITH FAILING CARD
    failing_pm_id = attach_payment_method!(stripe_customer, :pm_card_chargeCustomerFail)
    create_one_off_invoice(customer, [addon], units: 22)
    expect(stripe_customer.reload.payment_method_id).to eq failing_pm_id
    invoice = customer.invoices.sole
    expect(invoice.payment_status).to eq("failed")
    expect(invoice.payments.sole.status).to eq("failed")
    expect(webhooks_sent.map { it["webhook_type"] }).to include("invoice.payment_failure")
    webhooks_sent.clear

    # RetrieveLatestPaymentMethodService
    latest_id = PaymentProviderCustomers::Stripe::RetrieveLatestPaymentMethodService.call!(provider_customer: stripe_customer).payment_method_id
    expect(latest_id).to eq failing_pm_id

    # CREATING SUBSCRIPTION WITH PRE-AUTH
    response = create_subscription({
      plan_code: "any_plan",
      external_customer_id: "cust_#{external_id}"
    }, {
      amount_cents: 21_00,
      amount_currency: "EUR"
    })
    expect(response["error_details"]["code"]).to eq "card_declined"
    expect(response["error_details"]["http_body"]["error"]["code"]).to eq "card_declined"

    # WITH 3DSecure confirmation - no webhook, payment failed if customer is not in India
    threeds_pm_id = attach_payment_method!(stripe_customer, :pm_card_authenticationRequired)
    retry_invoice_payment(invoice.id)
    expect(stripe_customer.reload.payment_method_id).to eq threeds_pm_id
    expect(invoice.reload.payment_status).to eq("failed")
    expect(invoice.payment_attempts).to eq(2)
    expect(webhooks_sent.map { it["webhook_type"] }).not_to include("payment.requires_action")
    webhooks_sent.clear

    # WITH VALID CARD
    customer.update!(country: "FR")
    valid_pm_id = attach_payment_method!(stripe_customer, :pm_card_visa)
    retry_invoice_payment(invoice.id)
    expect(stripe_customer.reload.payment_method_id).to eq valid_pm_id
    expect(invoice.reload.payment_status).to eq("succeeded")
    expect(invoice.payment_attempts).to eq(3)

    perform_all_enqueued_jobs

    # CREATE A REFUND
    create_credit_note(invoice_id: invoice.id, reason: :other, refund_amount_cents: 12_00,
      items: [
        {fee_id: invoice.fees.first.id, amount_cents: 12_00}
      ])

    cn = invoice.reload.credit_notes.sole
    expect(cn.refund_amount_cents).to eq 12_00
    refund_id = cn.refunds.sole.provider_refund_id
    expect(refund_id).to start_with "re_"
    r = ::Stripe::Refund.retrieve(refund_id)
    expect(r.metadata.lago_credit_note_id).to eq cn.id
    expect(r.metadata.lago_invoice_id).to eq invoice.id
    expect(r.metadata.lago_customer_id).to eq customer.id

    # UPDATE THE CUSTOMER
    create_or_update_customer({
      external_id: "cust_#{external_id}",
      name: "Integration Test UPDATED #{Time.current.iso8601}"
    })
  end

  context "when customer is in India and has `require_action` on 3DS" do
    it do
      create_or_update_customer({
        external_id: "cust_#{external_id}",
        name: "[INDIA] Integration Test #{Time.current.iso8601}",
        currency:,
        country: "IN",
        billing_configuration: {
          payment_provider: "stripe",
          payment_provider_code: provider.code,
          sync: "true",
          sync_with_provider: "true",
          provider_payment_methods: [
            "card"
          ]
        }
      })
      webhooks_sent.clear
      customer = Customer.find(json[:customer][:lago_id])
      stripe_customer = customer.payment_provider_customers.sole

      threeds_pm_id = attach_payment_method!(stripe_customer, :pm_card_authenticationRequired)
      create_one_off_invoice(customer, [addon], units: 22)
      invoice = customer.invoices.sole
      expect(stripe_customer.reload.payment_method_id).to eq threeds_pm_id
      expect(invoice.reload.payment_status).to eq("pending")
      expect(invoice.payments.where(status: "requires_action").count).to eq 1
      expect(invoice.payment_attempts).to eq(1)
      expect(invoice).not_to be_ready_for_payment_processing
      wh = webhooks_sent.find { it["webhook_type"] == "payment.requires_action" }
      expect(wh.dig("payment", "next_action")).to match({
        "type" => "redirect_to_url",
        "redirect_to_url" => {
          "url" => start_with("https://hooks.stripe.com/3d_secure_2/hosted"),
          "return_url" => "https://app.lago.dev"
        }
      })
      webhooks_sent.clear
    end
  end

  context "with payment authorization" do
    it do
    end
  end

  # In Lago, we only attach payment method via checkout links
  def attach_payment_method!(stripe_customer, pm_id)
    customer_id = stripe_customer.provider_customer_id

    # Remove all existing methods
    Stripe::PaymentMethod.list({
      customer: customer_id,
      type: "card"
    }).each { Stripe::PaymentMethod.detach(it.id, {}) }

    # Attach new one
    res = Stripe::PaymentMethod.attach(pm_id.to_s, {customer: customer_id})
    res.id
  end
end
